import os
import logging
import hashlib
import base64
import json
import uuid
import traceback  # Added for error handling
from pathlib import Path
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List, Tuple
from fastapi import FastAPI, Request, HTTPException, WebSocket, WebSocketDisconnect, Depends, Form
from fastapi.responses import HTMLResponse, JSONResponse, RedirectResponse, FileResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from fastapi.staticfiles import StaticFiles
import uvicorn
import httpx
import asyncio
from contextlib import asynccontextmanager
import secrets
from collections import defaultdict
import random  # Retained only for non-metric quantum variance
import psutil  # For real-time system network and storage metrics
import subprocess  # For real routing table extraction and QSH commands
from jinja2 import Template
import socket  # For AF_INET constant
import sys
import types  # For sandboxing
from io import StringIO

# ==================== CONFIGURATION MODULE ====================
class Config:
    """Centralized configuration management"""
    # Environment
    ENVIRONMENT = os.getenv("ENVIRONMENT", "production")
    DEBUG = os.getenv("DEBUG", "false").lower() == "true"
    
    # Backend
    CHAT_BACKEND = os.getenv("CHAT_BACKEND_URL", "https://clearnet-chat-4bal.onrender.com")
    SKIP_BACKEND_CHECKS = os.getenv("SKIP_BACKEND_CHECKS", "true").lower() == "true"
    
    # Network
    MAX_RETRIES = int(os.getenv("MAX_RETRIES", "3"))
    TIMEOUT = int(os.getenv("TIMEOUT", "30"))
    RATE_LIMIT_PER_MINUTE = int(os.getenv("RATE_LIMIT_PER_MINUTE", "60"))
    
    # Quantum
    BLACK_HOLE_ADDRESS = "138.0.0.1"
    WHITE_HOLE_ADDRESS = "139.0.0.1"
    QUANTUM_REALM = "quantum.realm.domain.dominion.foam.computer.alice"
    NETWORKING_ADDRESS = "quantum.realm.domain.dominion.foam.computer.networking"
    FOAM_REPL_ADDRESS = "127.0.0.1:8000"  # Localhost integration for hybrid REPL
    
    # Bitcoin
    BITCOIN_UPDATE_INTERVAL = int(os.getenv("BITCOIN_UPDATE_INTERVAL", "30"))
    BITCOIN_RPC_USER = os.getenv("BITCOIN_RPC_USER", "hackah")
    BITCOIN_RPC_PASS = os.getenv("BITCOIN_RPC_PASS", "hackah")
    
    # Storage
    HOLOGRAPHIC_CAPACITY_TB = None  # Will be derived from real system
    QRAM_CAPACITY_QUBITS = 1000000000  # Cap for fictional mapping
    
    # Templates - changed to root directory
    TEMPLATES_DIR = Path(".")
    STATIC_DIR = Path("static")
    NOTEBOOKS_FILE = STATIC_DIR / "notebooks.json"  # For persistence

# Create static directory only
Config.STATIC_DIR.mkdir(exist_ok=True)

# ==================== LOGGING MODULE ====================
class Logger:
    """Centralized logging configuration"""
    
    @staticmethod
    def setup():
        logging.basicConfig(
            level=logging.INFO if not Config.DEBUG else logging.DEBUG,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.StreamHandler(),
                logging.FileHandler('app.log') if os.path.exists('/app') else logging.NullHandler()
            ]
        )
        return logging.getLogger(__name__)

logger = Logger.setup()

# ==================== QUANTUM ENTANGLEMENT MODULE ====================
class QuantumEntanglement:
    """Quantum entanglement management and measurement"""
    
    def __init__(self):
        self.entanglements = []
        self.initialize_entanglements()
    
    def initialize_entanglements(self):
        """Initialize quantum entanglements with dynamic timestamps"""
        now = datetime.now().isoformat()
        self.entanglements = [
            {
                "id": "QE-001",
                "name": "Black Hole ⚫ ↔ White Hole ⚪",
                "node_a": Config.BLACK_HOLE_ADDRESS,
                "node_b": Config.WHITE_HOLE_ADDRESS,
                "type": "Wormhole Bridge",
                "coherence": round(random.uniform(0.9990, 0.9999), 4),
                "fidelity": round(random.uniform(0.9980, 0.9998), 4),
                "bell_state": "|Φ+⟩",
                "speed_gbps": int(random.uniform(900000, 1100000)),  # Dynamic bandwidth
                "qubit_rate": int(random.uniform(900000000, 1100000000)),  # Dynamic qubit rate
                "distance_km": "Non-local (Einstein-Podolsky-Rosen)",
                "created": now,
                "entanglement_strength": "Maximum",
                "decoherence_time_ms": int(random.uniform(9000, 11000)),
                "status": "Active",
                "last_measurement": now,
                "torino_proof": "GHZ-like 27-qubit lattice fidelity: 0.9227 (post-QREM, EPLG 0.8%)"
            },
            {
                "id": "QE-002",
                "name": "Quantum Realm ⚛ ↔ Holographic Storage ⚫",
                "node_a": Config.QUANTUM_REALM,
                "node_b": Config.BLACK_HOLE_ADDRESS,
                "type": "Realm-Storage Link",
                "coherence": round(random.uniform(0.9985, 0.9995), 4),
                "fidelity": round(random.uniform(0.9980, 0.9994), 4),
                "bell_state": "|Ψ+⟩",
                "speed_gbps": int(random.uniform(450000, 550000)),
                "qubit_rate": int(random.uniform(450000000, 550000000)),
                "distance_km": "Cross-dimensional",
                "created": now,
                "entanglement_strength": "Very High",
                "decoherence_time_ms": int(random.uniform(7000, 9000)),
                "status": "Active",
                "last_measurement": now,
                "torino_proof": "TFIM evolution <Z>: -0.7812 (vs. -0.7544 theoretical, 2 Trotter steps)"
            },
            {
                "id": "QE-003",
                "name": "Networking Node 🌐 ↔ Quantum Realm ⚛",
                "node_a": Config.NETWORKING_ADDRESS,
                "node_b": Config.QUANTUM_REALM,
                "type": "Network-Quantum Bridge",
                "coherence": round(random.uniform(0.9980, 0.9990), 4),
                "fidelity": round(random.uniform(0.9970, 0.9988), 4),
                "bell_state": "|Φ-⟩",
                "speed_gbps": int(random.uniform(90000, 110000)),
                "qubit_rate": int(random.uniform(90000000, 110000000)),
                "distance_km": "127.0.0.1 (Local Quantum)",
                "created": now,
                "entanglement_strength": "High",
                "decoherence_time_ms": int(random.uniform(4000, 6000)),
                "status": "Active",
                "last_measurement": now,
                "torino_proof": "Negativity: 0.25 (bipartite slices), entropy: 0.12 bits (post-mitigation)"
            }
        ]
    
    def get_all_entanglements(self) -> List[Dict]:
        """Get all quantum entanglements with updated timestamps"""
        for ent in self.entanglements:
            ent["last_access"] = datetime.now().isoformat()
        return self.entanglements
    
    def get_entanglement_metrics(self) -> Dict:
        """Get aggregated entanglement metrics with real-time calculation"""
        entanglements = self.get_all_entanglements()
        return {
            "total_entanglements": len(entanglements),
            "active_entanglements": sum(1 for e in entanglements if e["status"] == "Active"),
            "average_coherence": round(sum(e["coherence"] for e in entanglements) / len(entanglements), 4),
            "average_fidelity": round(sum(e["fidelity"] for e in entanglements) / len(entanglements), 4),
            "total_bandwidth_gbps": sum(e["speed_gbps"] for e in entanglements),
            "total_qubit_rate": sum(e["qubit_rate"] for e in entanglements),
            "quantum_realm": Config.QUANTUM_REALM,
            "networking_node": Config.NETWORKING_ADDRESS,
            "measurement_timestamp": datetime.now().isoformat(),
            "torino_updates_2025": "IBM Quantum Loon (2025) for qLDPC testing; Starling (2029) fault-tolerant; advantage demos by 2026 end."
        }
    
    def measure_entanglement(self, entanglement_id: str) -> Dict:
        """Measure specific entanglement properties with real variance"""
        for ent in self.entanglements:
            if ent["id"] == entanglement_id:
                # Simulate real quantum measurement collapse with variance
                variance = random.uniform(-0.001, 0.001)
                measurement = ent.copy()
                measurement["measured_coherence"] = round(max(0.0, min(1.0, ent["coherence"] + variance)), 4)
                measurement["measured_fidelity"] = round(max(0.0, min(1.0, ent["fidelity"] + variance)), 4)
                measurement["measurement_time"] = datetime.now().isoformat()
                measurement["variance_applied"] = round(variance, 4)
                # Update original for persistence
                ent["coherence"] = measurement["measured_coherence"]
                ent["fidelity"] = measurement["measured_fidelity"]
                ent["last_measurement"] = measurement["measurement_time"]
                return measurement
        return {}

# ==================== PYTHON EXECUTOR FOR FOAM REPL ====================
class PythonExecutor:
    """Secure Python executor for Foam REPL (Jupyter-like kernel)"""
    
    SAFE_GLOBALS = {
        '__builtins__': {k: v for k, v in __builtins__.__dict__.items() if k not in ['eval', 'exec', 'compile', 'open']},  # Restricted
        'math': __import__('math'),
        'numpy': __import__('numpy'),
        # Add more safe modules as needed
    }
    
    def __init__(self):
        self.globals = self.SAFE_GLOBALS
        self.locals = {}
    
    def execute(self, code: str) -> Dict[str, Any]:
        """Execute Python code and capture output/error"""
        try:
            old_stdout = sys.stdout
            old_stderr = sys.stderr
            mystdout = StringIO()
            mystderr = StringIO()
            sys.stdout = mystdout
            sys.stderr = mystderr
            
            exec(code, self.globals, self.locals)
            
            sys.stdout = old_stdout
            sys.stderr = old_stderr
            
            output = mystdout.getvalue()
            error = mystderr.getvalue()
            
            return {
                "success": True,
                "output": output if output else None,
                "error": error if error else None,
                "type": "python",
                "traceback": None
            }
        except Exception as e:
            sys.stdout = old_stdout
            sys.stderr = old_stderr
            tb = traceback.format_exc()
            logger.error(f"Python execution error: {tb}")
            return {
                "success": False,
                "output": None,
                "error": str(e),
                "type": "python",
                "traceback": tb
            }

# ==================== SHELL EXECUTOR FOR QSH ====================
class ShellExecutor:
    """Shell executor for QSH commands"""
    
    ALLOWED_CMDS = ['ls', 'pwd', 'echo', 'qsh', 'ip', 'psutil', 'metrics']  # Whitelist
    
    def execute(self, command: str) -> Dict[str, Any]:
        """Execute shell command (supports qsh) and capture output/error"""
        cmd_parts = command.strip().split()[0] if command.strip() else ''
        if cmd_parts and cmd_parts not in self.ALLOWED_CMDS:
            return {
                "success": False,
                "output": None,
                "error": f"Command '{cmd_parts}' not allowed",
                "type": "shell",
                "traceback": None
            }
        
        if 'metrics' in command:
            # Special handling for metrics
            storage.update_storage_metrics()
            return {
                "success": True,
                "output": json.dumps({
                    "holographic": storage.holographic_storage,
                    "qram": storage.qram_storage
                }, indent=2),
                "error": None,
                "type": "shell",
                "traceback": None
            }
        
        try:
            result = subprocess.run(
                command, 
                shell=True, 
                capture_output=True, 
                text=True, 
                timeout=30,
                executable='/bin/bash' if os.name != 'nt' else None
            )
            return {
                "success": result.returncode == 0,
                "output": result.stdout.strip() if result.stdout else None,
                "error": result.stderr.strip() if result.stderr else None,
                "type": "shell",
                "traceback": None
            }
        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "output": None,
                "error": "Command timed out after 30 seconds",
                "type": "shell",
                "traceback": None
            }
        except Exception as e:
            tb = traceback.format_exc()
            logger.error(f"Shell execution error: {tb}")
            return {
                "success": False,
                "output": None,
                "error": str(e),
                "type": "shell",
                "traceback": tb
            }

python_executor = PythonExecutor()
shell_executor = ShellExecutor()

# ==================== STORAGE MODULE ====================
class Storage:
    """Data storage management with dynamic usage"""
    
    def __init__(self):
        # Email storage
        self.emails: Dict[str, List[Dict]] = {}
        self.user_emails: Dict[str, str] = {}
        
        # Chat storage
        self.chat_users: Dict[str, Dict] = {}
        self.chat_messages: List[Dict] = []
        self.active_sessions: Dict[str, str] = {}  # token -> username
        
        # Encrypted messages
        self.encrypted_messages: List[Dict] = []
        
        # Bitcoin cache
        self.bitcoin_cache: Dict[str, Any] = {
            "blockchain_info": None,
            "latest_blocks": [],
            "mempool_info": None,
            "network_stats": None,
            "last_update": None
        }
        
        # REPL Command History (QSH/Foam hybrid)
        self.command_history: List[Dict] = []
        
        # Jupyter-like Sessions (simple in-memory for demo)
        self.notebook_sessions: Dict[str, List[Dict]] = defaultdict(list)  # session_id -> cells [{"code": str, "output": Dict}]
        self.load_notebooks()  # Load persistent sessions
        
        # Initialize storage metrics with real data
        self.update_storage_metrics()
    
    def load_notebooks(self):
        """Load persistent notebook sessions"""
        if Config.NOTEBOOKS_FILE.exists():
            try:
                with open(Config.NOTEBOOKS_FILE, 'r') as f:
                    data = json.load(f)
                    self.notebook_sessions.update(data)
            except Exception as e:
                logger.warning(f"Failed to load notebooks: {e}")
    
    def save_notebooks(self):
        """Save notebook sessions"""
        try:
            with open(Config.NOTEBOOKS_FILE, 'w') as f:
                json.dump(dict(self.notebook_sessions), f, indent=2)
        except Exception as e:
            logger.warning(f"Failed to save notebooks: {e}")
    
    def update_storage_metrics(self):
        """Update storage metrics with real disk and RAM usage"""
        try:
            # Real Holographic (Disk)
            du = psutil.disk_usage('/')
            used_tb = du.used / (1024**4)  # Bytes to TB
            total_tb = du.total / (1024**4)
            Config.HOLOGRAPHIC_CAPACITY_TB = total_tb  # Derive capacity
            self.holographic_storage = {
                "total_capacity_tb": total_tb,
                "used_capacity_tb": used_tb,
                "available_capacity_tb": du.free / (1024**4),
                "efficiency": round(du.used / du.total, 2),
                "redundancy_factor": 3,
                "node_address": Config.BLACK_HOLE_ADDRESS,
                "last_update": datetime.now().isoformat()
            }
        except Exception as e:
            logger.warning(f"Disk usage fetch failed: {e}. Using defaults.")
            self.holographic_storage = {
                "total_capacity_tb": 1.0,  # Fallback
                "used_capacity_tb": 0.5,
                "available_capacity_tb": 0.5,
                "efficiency": 0.5,
                "redundancy_factor": 3,
                "node_address": Config.BLACK_HOLE_ADDRESS,
                "last_update": datetime.now().isoformat()
            }
        
        try:
            # Real QRAM (RAM)
            vm = psutil.virtual_memory()
            used_bytes = vm.used
            available_bytes = vm.available
            # Map to qubits: approximate 1 byte ~ 8 bits, cap at QRAM_CAPACITY
            used_qubits = min(used_bytes * 8, Config.QRAM_CAPACITY_QUBITS)
            available_qubits = min(available_bytes * 8, Config.QRAM_CAPACITY_QUBITS - used_qubits)
            uptime_ms = psutil.boot_time() * 1000  # Approximate coherence
            error_rate = vm.percent / 100.0  # Usage as error proxy
            self.qram_storage = {
                "total_capacity_qubits": Config.QRAM_CAPACITY_QUBITS,
                "used_capacity_qubits": int(used_qubits),
                "available_capacity_qubits": int(available_qubits),
                "coherence_time_ms": int(uptime_ms),
                "error_rate": round(error_rate, 4),
                "node_address": Config.QUANTUM_REALM,
                "last_update": datetime.now().isoformat()
            }
        except Exception as e:
            logger.warning(f"RAM usage fetch failed: {e}. Using defaults.")
            self.qram_storage = {
                "total_capacity_qubits": Config.QRAM_CAPACITY_QUBITS,
                "used_capacity_qubits": 500000000,
                "available_capacity_qubits": 500000000,
                "coherence_time_ms": 3600000,  # 1 hour fallback
                "error_rate": 0.5,
                "node_address": Config.QUANTUM_REALM,
                "last_update": datetime.now().isoformat()
            }
    
    def add_to_history(self, command: str, exec_type: str):
        """Add command to hybrid QSH/Foam history"""
        history_entry = {
            "id": str(uuid.uuid4()),
            "command": command,
            "type": exec_type,  # "qsh" or "foam" (python)
            "timestamp": datetime.now().isoformat(),
            "output": None  # Can be populated later
        }
        self.command_history.append(history_entry)
    
    def get_history(self, limit: int = 50) -> List[Dict]:
        """Get recent command history"""
        return self.command_history[-limit:]
    
    def create_notebook_session(self, session_id: str) -> str:
        """Initialize a new Jupyter-like session"""
        if session_id not in self.notebook_sessions:
            self.notebook_sessions[session_id] = []
        self.save_notebooks()
        return session_id
    
    def execute_notebook_cell(self, session_id: str, cell_id: str, code: str, exec_type: str = "foam") -> Dict:
        """Execute a notebook cell and store output"""
        if exec_type == "foam":
            result = python_executor.execute(code)
        else:  # qsh
            result = shell_executor.execute(code)
        
        cell = {
            "id": cell_id,
            "code": code,
            "output": result,
            "timestamp": datetime.now().isoformat()
        }
        
        # Update or append cell
        cells = self.notebook_sessions[session_id]
        for c in cells:
            if c["id"] == cell_id:
                c.update(cell)
                break
        else:
            cells.append(cell)
        
        self.add_to_history(code, exec_type)
        self.save_notebooks()  # Persist after execution
        return result
    
    def get_notebook_session(self, session_id: str) -> List[Dict]:
        """Get all cells for a session"""
        return self.notebook_sessions.get(session_id, [])
    
    # ... (rest of register_user, authenticate_user, etc. remain unchanged)
    def register_user(self, username: str, password: str, email: str) -> Dict:
        """Register new chat user"""
        if username in self.chat_users:
            return {"success": False, "message": "Username already exists"}
        
        user_id = str(uuid.uuid4())
        hashed_password = hashlib.sha256(password.encode()).hexdigest()
        
        self.chat_users[username] = {
            "id": user_id,
            "username": username,
            "password": hashed_password,
            "email": email,
            "created": datetime.now().isoformat()
        }
        
        # Create quantum foam email
        quantum_email = f"{username}::quantum.foam"
        self.user_emails[username] = quantum_email
        self.emails[username] = []
        
        return {
            "success": True,
            "user_id": user_id,
            "username": username,
            "email": quantum_email
        }
    
    def authenticate_user(self, username: str, password: str) -> Optional[str]:
        """Authenticate user and return token"""
        if username not in self.chat_users:
            return None
        
        hashed_password = hashlib.sha256(password.encode()).hexdigest()
        if self.chat_users[username]["password"] != hashed_password:
            return None
        
        # Generate token
        token = secrets.token_urlsafe(32)
        self.active_sessions[token] = username
        
        return token
    
    def get_user_from_token(self, token: str) -> Optional[Dict]:
        """Get user from token"""
        username = self.active_sessions.get(token)
        if username and username in self.chat_users:
            return self.chat_users[username]
        return None
    
    def add_chat_message(self, username: str, content: str) -> Dict:
        """Add chat message"""
        message = {
            "id": str(uuid.uuid4()),
            "sender": username,
            "content": content,
            "timestamp": datetime.now().isoformat()
        }
        self.chat_messages.append(message)
        return message
    
    def get_recent_messages(self, limit: int = 50) -> List[Dict]:
        """Get recent chat messages"""
        return self.chat_messages[-limit:]
    
    def add_email(self, username: str, email: Dict):
        """Add email to user's inbox"""
        if username not in self.emails:
            self.emails[username] = []
        self.emails[username].append(email)
    
    def get_inbox(self, username: str) -> List[Dict]:
        """Get user's inbox"""
        return self.emails.get(username, [])
    
    def mark_email_read(self, username: str, email_id: str):
        """Mark email as read"""
        if username in self.emails:
            for email in self.emails[username]:
                if email["id"] == email_id:
                    email["read"] = True
                    break

storage = Storage()
quantum_entanglement = QuantumEntanglement()

# ==================== BITCOIN MODULE ====================
# (Unchanged for brevity)

class BitcoinMainnet:
    """Real Bitcoin mainnet data fetcher using blockchain APIs"""
    
    BLOCKCHAIN_API = "https://blockchain.info"
    MEMPOOL_API = "https://mempool.space/api"
    
    @staticmethod
    async def get_latest_block() -> Dict:
        """Get latest block from blockchain"""
        try:
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.get(f"{BitcoinMainnet.BLOCKCHAIN_API}/latestblock")
                return response.json()
        except Exception as e:
            logger.error(f"Error fetching latest block: {e}")
            return {}
    
    @staticmethod
    async def get_blockchain_stats() -> Dict:
        """Get blockchain statistics"""
        try:
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.get(f"{BitcoinMainnet.BLOCKCHAIN_API}/stats?format=json")
                return response.json()
        except Exception as e:
            logger.error(f"Error fetching blockchain stats: {e}")
            return {}
    
    @staticmethod
    async def get_mempool_info() -> Dict:
        """Get mempool information"""
        try:
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.get(f"{BitcoinMainnet.MEMPOOL_API}/mempool")
                return response.json()
        except Exception as e:
            logger.error(f"Error fetching mempool info: {e}")
            return {}
    
    @staticmethod
    async def get_recent_blocks(count: int = 10) -> List[Dict]:
        """Get recent blocks"""
        try:
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.get(f"{BitcoinMainnet.MEMPOOL_API}/blocks")
                blocks = response.json()
                return blocks[:count] if isinstance(blocks, list) else []
        except Exception as e:
            logger.error(f"Error fetching recent blocks: {e}")
            return []
    
    @staticmethod
    async def get_block_by_hash(block_hash: str) -> Dict:
        """Get block details by hash"""
        try:
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.get(f"{BitcoinMainnet.BLOCKCHAIN_API}/rawblock/{block_hash}")
                return response.json()
        except Exception as e:
            logger.error(f"Error fetching block: {e}")
            return {}
    
    @staticmethod
    async def get_transaction(txid: str) -> Dict:
        """Get transaction details"""
        try:
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.get(f"{BitcoinMainnet.BLOCKCHAIN_API}/rawtx/{txid}")
                return response.json()
        except Exception as e:
            logger.error(f"Error fetching transaction: {e}")
            return {}
    
    @staticmethod
    async def get_address_info(address: str) -> Dict:
        """Get address information"""
        try:
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.get(f"{BitcoinMainnet.BLOCKCHAIN_API}/rawaddr/{address}")
                return response.json()
        except Exception as e:
            logger.error(f"Error fetching address info: {e}")
            return {}

class BitcoinCLI:
    """Bitcoin CLI commands with real mainnet data"""
    
    @staticmethod
    async def execute_command(command: str) -> Dict[str, Any]:
        """Execute bitcoin-cli command
